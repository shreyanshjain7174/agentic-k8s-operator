// Auto-generated tests for phase1-010

```go
// pkg/models/proposal_test.go
package models

import (
	"strings"
	"testing"
	"time"
)

func TestApprovedProposal_GetBranchName(t *testing.T) {
	tests := []struct {
		name        string
		proposalID  string
		title       string
		expected    string
	}{
		{
			name:       "simple title",
			proposalID: "abc123def456",
			title:      "Add New Feature",
			expected:   "swarm/proposal-abc123de-add-new-feature",
		},
		{
			name:       "title with special characters",
			proposalID: "xyz789",
			title:      "Fix Bug: Memory Leak!!!",
			expected:   "swarm/proposal-xyz789-fix-bug-memory-leak",
		},
		{
			name:       "long title truncated",
			proposalID: "short",
			title:      "This is a very long title that should be truncated to forty characters maximum",
			expected:   "swarm/proposal-short-this-is-a-very-long-title-that-should-b",
		},
		{
			name:       "title with multiple spaces",
			proposalID: "test123",
			title:      "Multiple    Spaces    Here",
			expected:   "swarm/proposal-test123-multiple-spaces-here",
		},
		{
			name:       "title with underscores and dots",
			proposalID: "prop_001",
			title:      "file_name.test.go",
			expected:   "swarm/proposal-prop_001-file-name-test-go",
		},
		{
			name:       "short proposal ID",
			proposalID: "ab",
			title:      "Test",
			expected:   "swarm/proposal-ab-test",
		},
		{
			name:       "title starting and ending with hyphens",
			proposalID: "test",
			title:      "---Title---",
			expected:   "swarm/proposal-test-title",
		},
		{
			name:       "empty title",
			proposalID: "empty123",
			title:      "",
			expected:   "swarm/proposal-empty123-",
		},
		{
			name:       "unicode characters",
			proposalID: "unicode",
			title:      "Hello ‰∏ñÁïå Test",
			expected:   "swarm/proposal-unicode-hello-test",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			proposal := &ApprovedProposal{
				Metadata: ProposalMetadata{
					ID:    tt.proposalID,
					Title: tt.title,
				},
			}

			result := proposal.GetBranchName()
			if result != tt.expected {
				t.Errorf("GetBranchName() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestAgentRole_Title(t *testing.T) {
	tests := []struct {
		name     string
		role     AgentRole
		expected string
	}{
		{
			name:     "PM role",
			role:     RolePM,
			expected: "Pm",
		},
		{
			name:     "Architect role",
			role:     RoleArchitect,
			expected: "Architect",
		},
		{
			name:     "Engineer role",
			role:     RoleEngineer,
			expected: "Engineer",
		},
		{
			name:     "QA role",
			role:     RoleQA,
			expected: "Qa",
		},
		{
			name:     "Security role",
			role:     RoleSecurity,
			expected: "Security",
		},
		{
			name:     "Documentation role",
			role:     RoleDocumentation,
			expected: "Documentation",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.role.Title()
			if result != tt.expected {
				t.Errorf("Title() = %q, want %q", result, tt.expected)
			}
		})
	}
}

// pkg/github/pr_generator_test.go
package github

import (
	"strings"
	"testing"
	"time"

	"github.com/shreyanshjain7174/clawdlinux/pkg/models"
)

func TestGenerator_GenerateTitle(t *testing.T) {
	g := NewGenerator()

	tests := []struct {
		name     string
		title    string
		expected string
	}{
		{
			name:     "simple title",
			title:    "Add Feature X",
			expected: "[Swarm] Add Feature X",
		},
		{
			name:     "empty title",
			title:    "",
			expected: "[Swarm] ",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			proposal := &models.ApprovedProposal{
				Metadata: models.ProposalMetadata{
					Title: tt.title,
				},
			}

			result := g.GenerateTitle(proposal)
			if result != tt.expected {
				t.Errorf("GenerateTitle() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestGenerator_GenerateBody(t *testing.T) {
	g := NewGenerator()
	timestamp := time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC)

	proposal := &models.ApprovedProposal{
		Metadata: models.ProposalMetadata{
			ID:          "test-123",
			Title:       "Test Proposal",
			Description: "Test description",
			CreatedAt:   timestamp,
			LoopNumber:  5,
		},
		ConsensusScore:        85.5,
		ImplementationSummary: "Implementation details here",
		Votes: []models.AgentVote{
			{
				AgentRole: models.RoleArchitect,
				Decision:  models.DecisionApprove,
				Score:     90.0,
				Reasoning: "Good architecture",
			},
		},
	}

	body := g.GenerateBody(proposal)

	// Check key sections are present
	requiredSections := []string{
		"## ü§ñ Auto-Generated by ClawdLinux Autonomous Swarm",
		"### Proposal Summary",
		"Test description",
		"### Implementation",
		"Implementation details here",
		"### Consensus Scores",
		"**Overall Approval: 85.5/100**",
		"### Review Checklist",
		"Proposal ID: `test-123`",
		"Loop: #5",
		"2024-01-15 10:30:00 UTC",
	}

	for _, section := range requiredSections {
		if !strings.Contains(body, section) {
			t.Errorf("GenerateBody() missing section: %q", section)
		}
	}
}

func TestGenerator_generateVotesTable(t *testing.T) {
	g := NewGenerator()

	tests := []struct {
		name     string
		votes    []models.AgentVote
		expected []string
	}{
		{
			name: "sorted by score descending",
			votes: []models.AgentVote{
				{
					AgentRole: models.RoleEngineer,
					Decision:  models.DecisionApprove,
					Score:     80.0,
					Reasoning: "Good code",
				},
				{
					AgentRole: models.RoleArchitect,
					Decision:  models.DecisionApprove,
					Score:     95.0,
					Reasoning: "Excellent design",
				},
			},
			expected: []string{
				"| Architect | ‚úÖ APPROVE | 95.0 | Excellent design |",
				"| Engineer | ‚úÖ APPROVE | 80.0 | Good code |",
			},
		},
		{
			name: "different decision types",
			votes: []models.AgentVote{
				{
					AgentRole: models.RoleQA,
					Decision:  models.DecisionReject,
					Score:     40.0,
					Reasoning: "Needs tests",
				},
				{
					AgentRole: models.RoleSecurity,
					Decision:  models.DecisionConditionalApprove,
					Score:     70.0,
					Reasoning: "Add input validation",
				},
			},
			expected: []string{
				"| Security | ‚ö†Ô∏è CONDITIONAL_APPROVE | 70.0 | Add input validation |",
				"| Qa | ‚ùå REJECT | 40.0 | Needs tests |",
			},
		},
		{
			name: "truncated long reasoning",
			votes: []models.AgentVote{
				{
					AgentRole: models.RoleDocumentation,
					Decision:  models.DecisionApprove,
					Score:     88.0,
					Reasoning: "This is a very long reasoning text that should be truncated to sixty characters maximum for display",
				},
			},
			expected: []string{
				"| Documentation | ‚úÖ APPROVE | 88.0 | This is a very long reasoning text that should be truncated t... |",
			},
		},
		{
			name:     "empty votes",
			votes:    []models.AgentVote{},
			expected: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.generateVotesTable(tt.votes)

			// Always check header
			if !strings.Contains(result, "| Agent | Decision | Score | Reasoning |") {
				t.Error("generateVotesTable() missing header")
			}

			// Check expected rows
			for _, expected := range tt.expected {
				if !strings.Contains(result, expected) {
					t.Errorf("generateVotesTable() missing row: %q", expected)
				}
			}
		})
	}
}

func TestGenerator_generateChecklist(t *testing.T) {
	g := NewGenerator()
	result := g.generateChecklist()

	expectedItems := []string{
		"- [ ] Code quality meets standards",
		"- [ ] Tests pass (if applicable)",
		"- [ ] Documentation updated",
		"- [ ] No security vulnerabilities introduced",
		"- [ ] Consensus scores reviewed and acceptable",
	}

	for _, item := range expectedItems {
		if !strings.Contains(result, item) {
			t.Errorf("generateChecklist() missing item: %q", item)
		}
	}
}

// pkg/github/retry_test.go
package github

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/sirupsen/logrus"
)

func TestDefaultRetryConfig(t *testing.T) {
	config := DefaultRetryConfig()

	if config.MaxAttempts != 3 {
		t.Errorf("MaxAttempts = %d, want 3", config.MaxAttempts)
	}
	if config.BaseDelay != 1*time.Second {
		t.Errorf("BaseDelay = %v, want 1s", config.BaseDelay)
	}
	if config.MaxDelay != 30*time.Second {
		t.Errorf("MaxDelay = %v, want 30s", config.MaxDelay)
	}
}

func TestWithRetry_Success(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	callCount := 0
	fn := func(ctx context.Context) error {
		callCount++
		return nil
	}

	err := WithRetry(context.Background(), nil, logger, "TestFunc", fn)
	if err != nil {
		t.Errorf("WithRetry() unexpected error: %v", err)
	}
	if callCount != 1 {
		t.Errorf("function called %d times, want 1", callCount)
	}
}

func TestWithRetry_SuccessOnSecondAttempt(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	config := &RetryConfig{
		MaxAttempts: 3,
		BaseDelay:   10 * time.Millisecond,
		MaxDelay:    100 * time.Millisecond,
	}

	callCount := 0
	fn := func(ctx context.Context) error {
		callCount++
		if callCount < 2 {
			return errors.New("temporary error")
		}
		return nil
	}

	err := WithRetry(context.Background(), config, logger, "TestFunc", fn)
	if err != nil {
		t.Errorf("WithRetry() unexpected error: %v", err)
	}
	if callCount != 2 {
		t.Errorf("function called %d times, want 2", callCount)
	}
}

func TestWithRetry_AllAttemptsFail(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	config := &RetryConfig{
		MaxAttempts: 3,
		BaseDelay:   10 * time.Millisecond,
		MaxDelay:    100 * time.Millisecond,
	}

	expectedErr := errors.New("persistent error")
	callCount := 0
	fn := func(ctx context.Context) error {
		callCount++
		return expectedErr
	}

	err := WithRetry(context.Background(), config, logger, "TestFunc", fn)
	if err == nil {
		t.Error("WithRetry() expected error, got nil")
	}
	if callCount != 3 {
		t.Errorf("function called %d times, want 3", callCount)
	}
	if !strings.Contains(err.Error(), "failed after 3 attempts") {
		t.Errorf("error message = %q, want 'failed after 3 attempts'", err.Error())
	}
}

func TestWithRetry_ContextCanceled(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	config := &RetryConfig{
		MaxAttempts: 5,
		BaseDelay:   100 * time.Millisecond,
		MaxDelay:    1 * time.Second,
	}

	ctx, cancel := context.WithCancel(context.Background())

	callCount := 0
	fn := func(ctx context.Context) error {
		callCount++
		if callCount == 2 {
			cancel()
		}
		return errors.New("error")
	}

	err := WithRetry(ctx, config, logger, "TestFunc", fn)
	if err == nil {
		t.Error("WithRetry() expected error, got nil")
	}
	if !errors.Is(err, context.Canceled) {
		t.Errorf("error = %v, want context.Canceled", err)
	}
}

func TestWithRetry_ExponentialBackoff(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	config := &RetryConfig{
		MaxAttempts: 4,
		BaseDelay:   10 * time.Millisecond,
		MaxDelay:    100 * time.Millisecond,
	}

	var delays []time.Duration
	var lastTime time.Time

	callCount := 0
	fn := func(ctx context.Context) error {
		callCount++
		now := time.Now()
		if !lastTime.IsZero() {
			delays = append(delays, now.Sub(lastTime))
		}
		lastTime = now
		return errors.New("error")
	}

	_ = WithRetry(context.Background(), config, logger, "TestFunc", fn)

	// Check that delays are increasing (exponential backoff)
	if len(delays) < 2 {
		t.Fatalf("not enough delays recorded: %d", len(delays))
	}

	for i := 1; i < len(delays); i++ {
		if delays[i] < delays[i-1] {
			t.Errorf("delay[%d] = %v is less than delay[%d] = %v (not exponential)", i, delays[i], i-1, delays[i-1])
		}
	}
}

func TestWithRetry_MaxDelayEnforced(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	config := &RetryConfig{
		MaxAttempts: 10,
		BaseDelay:   1 * time.Millisecond,
		MaxDelay:    10 * time.Millisecond,
	}

	var delays []time.Duration
	var lastTime time.Time

	fn := func(ctx context.Context) error {
		now := time.Now()
		if !lastTime.IsZero() {
			delays = append(delays, now.Sub(lastTime))
		}
		lastTime = now
		return errors.New("error")
	}

	_ = WithRetry(context.Background(), config, logger, "TestFunc", fn)

	// All delays should be <= MaxDelay
	for i, delay := range delays {
		if delay > config.MaxDelay+5*time.Millisecond { // small tolerance
			t.Errorf("delay[%d] = %v exceeds MaxDelay %v", i, delay, config.MaxDelay)
		}
	}
}

// pkg/github/integration_test.go
package github

import (
	"bytes"
	"context"
	"encoding/json"
	"os"
	"testing"
	"time"

	"github.com/shreyanshjain7174/clawdlinux/pkg/models"
	"github.com/sirupsen/logrus"
)

func TestLoadConfigFromEnv(t *testing.T) {
	tests := []struct {
		name          string
		envVars       map[string]string
		expectedError bool
		expectedOwner string
		expectedRepo  string
	}{
		{
			name: "all env vars set",
			envVars: map[string]string{
				"GITHUB_TOKEN":      "test-token",
				"GITHUB_REPO_OWNER": "test-owner",
				"GITHUB_REPO_NAME":  "test-repo",
			},
			expectedError: false,
			expectedOwner: "test-owner",
			expectedRepo:  "test-repo",
		},
		{
			name: "only token set - uses defaults",
			envVars: map[string]string{
				"GITHUB_TOKEN": "test-token",
			},
			expectedError: false,
			expectedOwner: "shreyanshjain7174",
			expectedRepo:  "clawdlinux",
		},
		{
			name:          "no token - error",
			envVars:       map[string]string{},
			expectedError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Clear env
			os.Clearenv()

			// Set test env vars
			for k, v := range tt.envVars {
				os.Setenv(k, v)
			}

			config, err := LoadConfigFromEnv()

			if tt.expectedError {
				if err == nil {
					t.Error("LoadConfigFromEnv() expected error, got nil")
				}
				return
			}

			if err != nil {
				t.Errorf("LoadConfigFromEnv() unexpected error: %v", err)
				return
			}

			if config.RepoOwner != tt.expectedOwner {
				t.Errorf("RepoOwner = %q, want %q", config.RepoOwner, tt.expectedOwner)
			}
			if config.RepoName != tt.expectedRepo {
				t.Errorf("RepoName = %q, want %q", config.RepoName, tt.expectedRepo)
			}
		})
	}
}

func TestPRCreationLogger_LogPRCreation(t *testing.T) {
	var buf bytes.Buffer
	logger := logrus.New()
	logger.SetOutput(&buf)
	logger.SetFormatter(&logrus.JSONFormatter{})

	prLogger := NewPRCreationLogger(logger)

	tests := []struct {
		name       string
		proposalID string
		metadata   *models.PRMetadata
		success    bool
		wantFields map[string]interface{}
	}{
		{
			name:       "successful PR creation",
			proposalID: "test-123",
			metadata: &models.PRMetadata{
				ProposalID: "test-123",
				BranchName: "swarm/test",
				PRNumber:   intPtr(42),
				PRURL:      strPtr("https://github.com/test/test/pull/42"),
				CreatedAt:  time.Now().UTC(),
			},
			success: true,
			wantFields: map[string]interface{}{
				"event":       "pr_created",
				"proposal_id": "test-123",
				"pr_number":   float64(42),
				"pr_url":      "https://github.com/test/test/pull/42",
				"success":     true,
			},
		},
		{
			name:       "failed PR creation",
			proposalID: "test-456",
			metadata: &models.PRMetadata{
				ProposalID: "test-456",
				BranchName: "swarm/test",
				CreatedAt:  time.Now().UTC(),
				Error:      strPtr("API error"),
			},
			success: false,
			wantFields: map[string]interface{}{
				"event":       "pr_created",
				"proposal_id": "test-456",
				"success":     false,
				"error":       "API error",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf.Reset()

			prLogger.LogPRCreation(tt.proposalID, tt.metadata, tt.success)

			var logEntry map[string]interface{}
			if err := json.Unmarshal(buf.Bytes(), &logEntry); err != nil {
				t.Fatalf("failed to unmarshal log entry: %v", err)
			}

			for key, expectedValue := range tt.wantFields {
				if logEntry[key] != expectedValue {
					t.Errorf("log field %q = %v, want %v", key, logEntry[key], expectedValue)
				}
			}
		})
	}
}

func TestEvaluateConsensusAndCreatePR_BelowThreshold(t *testing.T) {
	logger := logrus.New()
	logger.SetOutput(testing.Verbose())

	proposal := &models.ApprovedProposal{
		Metadata: models.ProposalMetadata{
			ID:    "test-123",
			Title: "Test",
		},
		ConsensusScore: 70.0, // Below 80.0 threshold
	}

	// Should not call orchestrator for low consensus
	err := EvaluateConsensusAndCreatePR(context.Background(), proposal, nil, logger)
	if err != nil {
		t.Errorf("EvaluateConsensusAndCreatePR() unexpected error: %v", err)
	}
}

func intPtr(i int) *int {
	return &i
}

func strPtr(s string) *string {
	return &s
}
```